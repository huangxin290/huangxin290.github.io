(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{458:function(t,a,v){"use strict";v.r(a);var r=v(2),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"基础概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础概念"}},[t._v("#")]),t._v(" 基础概念")]),t._v(" "),a("h3",{attrs:{id:"元编程-meta-programming"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元编程-meta-programming"}},[t._v("#")]),t._v(" 元编程（meta programming）")]),t._v(" "),a("blockquote",[a("p",[t._v("框架的作者使用一种编程语言的固有的语言特性，创造出"),a("strong",[t._v("相对新")]),t._v("的语言特性，使得最终使用者能够以"),a("strong",[t._v("新的语法和语义")]),t._v("来构建他们的应用程序，从而在某些领域开发中获得更好的开发体验。")])]),t._v(" "),a("p",[t._v("例如 vue 的作者，利用 js 语言固有的特性，创造出 vue 这个新的语言特性，在 js 的基础上构建属于 vue 的新的语法和语义，在使用 vue 的人更轻松的进行前端编程开发。（JQuery也差不多，创造了链式语法，在以前加快了前端开发）")]),t._v(" "),a("h3",{attrs:{id:"渐进式框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渐进式框架"}},[t._v("#")]),t._v(" 渐进式框架")]),t._v(" "),a("p",[t._v("就是把框架分层，例如vue，最核心的机制是"),a("code",[t._v("视图层渲染")]),t._v("，然后是"),a("code",[t._v("组件机制")]),t._v("，"),a("code",[t._v("路由机制")]),t._v("，"),a("code",[t._v("状态管理")]),t._v("，最后是"),a("code",[t._v("构建工具")]),t._v("。我们可以只使用最里层的视图层渲染，也可以使用整个全家桶来开发，从而适配不同的需求。")]),t._v(" "),a("h3",{attrs:{id:"引入虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引入虚拟dom"}},[t._v("#")]),t._v(" 引入虚拟DOM")]),t._v(" "),a("p",[t._v("在80%的场景下渲染速度变得更快了，在20%的场景下反而变慢了，不要人云亦云。")]),t._v(" "),a("h2",{attrs:{id:"变化侦测"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变化侦测"}},[t._v("#")]),t._v(" 变化侦测")]),t._v(" "),a("p",[t._v("Vue.js 会自动通过状态生成 DOM, 并将其输出到页面上显示出来，这个过程叫渲染。Vue.js的渲染过程是声明式的，我们通过模板来描述状态与 DOM 之间的映射关系。")]),t._v(" "),a("h3",{attrs:{id:"变化侦测的两种类型-推-和-拉"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变化侦测的两种类型-推-和-拉"}},[t._v("#")]),t._v(" 变化侦测的两种类型 推 和 拉")]),t._v(" "),a("p",[t._v("Angular 和 React 中的变化侦测都属于 “拉”，这就是说当状态发生变化时，它不知道哪个状态变了，只知道状态有可能变了，然后会发送一个信号告诉框架，框架内部收到信号后，会进行一个暴力比对来找出哪些 DOM 节点需要重新渲染。这在 Angular 中是脏检查的流程，在 React 中使用的是虚拟 DOM。")]),t._v(" "),a("p",[t._v("而 Vue.js 的变化侦测属于 “推”。当状态发生变化时，Vue.js "),a("strong",[t._v("立刻")]),t._v("就知道了，而且在一定程度上知道哪些状态变了。 因此，它知道的信息更多，也就可以进行更细粒度的更新。所谓更细粒度的更新，就是说：假如有一个状态绑定着好多个依赖，每个依赖表示一个具体的 DOM 节点，那么当这个状态发生变化时，向这个状态的所有依赖发送通知，让它们进行 DOM 更新操作。相比较而言， “拉” 的粒度是最粗的。\n但是它也有一定的代价， 因为粒度越细，每个状态所绑定的依赖就越多，依赖追踪在内存上的开销就会越大。 因此，从 Vue.js 2.0 开始，它引入了虚拟 DOM, 将粒度调整为中等粒度，即一个状态所绑定的依赖不再是具体的 DOM 节点，而是一个组件。这样状态变化后，会通知到组件，组件内部再使用虚拟 DOM 进行比对。 这可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。")]),t._v(" "),a("h3",{attrs:{id:"实际实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实际实现"}},[t._v("#")]),t._v(" 实际实现")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/blogs/vue/深入理解vue的响应式原理.html"}},[t._v("深入理解vue的响应式原理")])],1)])}),[],!1,null,null,null);a.default=s.exports}}]);